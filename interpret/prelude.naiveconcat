-- FLOW CONTROL


-- if
-- `{"consequent" say} {"alternative" say} false if apply`
-- => "alternative"
{
    "predicate" let 
    "alternative" let
    "consequent" let
    consequent predicate then
    alternative predicate not then
    apply
} "if" define


-- each
-- Not tail recursive, could have bad performance
{
    "f" let
    length "l" let
    {
        lop 
        f apply
        {f each}  length 0 = not  then apply
    } l 0 = not   then apply
} "each" define


-- reduce
-- `{1 2 3} {+} 1 reduce`
-- => 7
{
  "f" let
  "accumulator" let
  length "l" let
  {
    lop "x" let
    length "next_l" let
    accumulator x f apply
    {f reduce} {swap drop} next_l 0 = not if  
  } l 0 = not then apply
} "reduce" define


-- STACK MANIPULATION


-- swap
{
    "a" let
    "b" let
    a b
} "swap" define



-- STRINGS


{
  find "index" let
  "delimiter" let
  "original" let

  { 
    original index split  -- split before the delimiter
    delimiter length swap drop  -- drop the delimiter
    split swap drop
    swap {} append append  -- quote the two values
  } 
  { original {} append } 
  index 0 >= if 
 
} "split_on" define



-- CONCAT


{ swap {append} reduce } "concat" define
